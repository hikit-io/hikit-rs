/* automatically generated by rust-bindgen 0.60.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub const _LIBCPP_VERSION: u32 = 13000;
    pub const _LIBCPP_ABI_VERSION: u32 = 1;
    pub const _LIBCPP_STD_VER: u32 = 11;
    pub const _LIBCPP_OBJECT_FORMAT_MACHO: u32 = 1;
    pub const _LIBCPP_HIDE_FROM_ABI_PER_TU: u32 = 1;
    pub const _LIBCPP_DEBUG_LEVEL: u32 = 0;
    pub const _LIBCPP_LOCALE__L_EXTENSIONS: u32 = 1;
    pub const __WORDSIZE: u32 = 64;
    pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
    pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
    pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
    pub const __DARWIN_UNIX03: u32 = 1;
    pub const __DARWIN_64_BIT_INO_T: u32 = 1;
    pub const __DARWIN_VERS_1050: u32 = 1;
    pub const __DARWIN_NON_CANCELABLE: u32 = 0;
    pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
    pub const __DARWIN_C_ANSI: u32 = 4096;
    pub const __DARWIN_C_FULL: u32 = 900000;
    pub const __DARWIN_C_LEVEL: u32 = 900000;
    pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
    pub const __DARWIN_NO_LONG_LONG: u32 = 0;
    pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
    pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
    pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
    pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
    pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
    pub const __has_ptrcheck: u32 = 0;
    pub const __PTHREAD_SIZE__: u32 = 8176;
    pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
    pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
    pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
    pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
    pub const __PTHREAD_COND_SIZE__: u32 = 40;
    pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
    pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
    pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
    pub const INT8_MAX: u32 = 127;
    pub const INT16_MAX: u32 = 32767;
    pub const INT32_MAX: u32 = 2147483647;
    pub const INT64_MAX: u64 = 9223372036854775807;
    pub const INT8_MIN: i32 = -128;
    pub const INT16_MIN: i32 = -32768;
    pub const INT32_MIN: i32 = -2147483648;
    pub const INT64_MIN: i64 = -9223372036854775808;
    pub const UINT8_MAX: u32 = 255;
    pub const UINT16_MAX: u32 = 65535;
    pub const UINT32_MAX: u32 = 4294967295;
    pub const UINT64_MAX: i32 = -1;
    pub const INT_LEAST8_MIN: i32 = -128;
    pub const INT_LEAST16_MIN: i32 = -32768;
    pub const INT_LEAST32_MIN: i32 = -2147483648;
    pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
    pub const INT_LEAST8_MAX: u32 = 127;
    pub const INT_LEAST16_MAX: u32 = 32767;
    pub const INT_LEAST32_MAX: u32 = 2147483647;
    pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
    pub const UINT_LEAST8_MAX: u32 = 255;
    pub const UINT_LEAST16_MAX: u32 = 65535;
    pub const UINT_LEAST32_MAX: u32 = 4294967295;
    pub const UINT_LEAST64_MAX: i32 = -1;
    pub const INT_FAST8_MIN: i32 = -128;
    pub const INT_FAST16_MIN: i32 = -32768;
    pub const INT_FAST32_MIN: i32 = -2147483648;
    pub const INT_FAST64_MIN: i64 = -9223372036854775808;
    pub const INT_FAST8_MAX: u32 = 127;
    pub const INT_FAST16_MAX: u32 = 32767;
    pub const INT_FAST32_MAX: u32 = 2147483647;
    pub const INT_FAST64_MAX: u64 = 9223372036854775807;
    pub const UINT_FAST8_MAX: u32 = 255;
    pub const UINT_FAST16_MAX: u32 = 65535;
    pub const UINT_FAST32_MAX: u32 = 4294967295;
    pub const UINT_FAST64_MAX: i32 = -1;
    pub const INTPTR_MAX: u64 = 9223372036854775807;
    pub const INTPTR_MIN: i64 = -9223372036854775808;
    pub const UINTPTR_MAX: i32 = -1;
    pub const SIZE_MAX: i32 = -1;
    pub const RSIZE_MAX: i32 = -1;
    pub const WINT_MIN: i32 = -2147483648;
    pub const WINT_MAX: u32 = 2147483647;
    pub const SIG_ATOMIC_MIN: i32 = -2147483648;
    pub const SIG_ATOMIC_MAX: u32 = 2147483647;
    pub const AGORA_RTM_ENDCALL_PREFIX: &[u8; 45usize] =
        b"AgoraRTMLegacyEndcallCompatibleMessagePrefix\0";
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub type int_least8_t = i8;
    pub type int_least16_t = i16;
    pub type int_least32_t = i32;
    pub type int_least64_t = i64;
    pub type uint_least8_t = u8;
    pub type uint_least16_t = u16;
    pub type uint_least32_t = u32;
    pub type uint_least64_t = u64;
    pub type int_fast8_t = i8;
    pub type int_fast16_t = i16;
    pub type int_fast32_t = i32;
    pub type int_fast64_t = i64;
    pub type uint_fast8_t = u8;
    pub type uint_fast16_t = u16;
    pub type uint_fast32_t = u32;
    pub type uint_fast64_t = u64;
    pub type __int8_t = ::std::os::raw::c_schar;
    pub type __uint8_t = ::std::os::raw::c_uchar;
    pub type __int16_t = ::std::os::raw::c_short;
    pub type __uint16_t = ::std::os::raw::c_ushort;
    pub type __int32_t = ::std::os::raw::c_int;
    pub type __uint32_t = ::std::os::raw::c_uint;
    pub type __int64_t = ::std::os::raw::c_longlong;
    pub type __uint64_t = ::std::os::raw::c_ulonglong;
    pub type __darwin_intptr_t = ::std::os::raw::c_long;
    pub type __darwin_natural_t = ::std::os::raw::c_uint;
    pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __mbstate_t {
        pub __mbstate8: [::std::os::raw::c_char; 128usize],
        pub _mbstateL: ::std::os::raw::c_longlong,
    }
    #[test]
    fn bindgen_test_layout___mbstate_t() {
        assert_eq!(
            ::core::mem::size_of::<__mbstate_t>(),
            128usize,
            concat!("Size of: ", stringify!(__mbstate_t))
        );
        assert_eq!(
            ::core::mem::align_of::<__mbstate_t>(),
            8usize,
            concat!("Alignment of ", stringify!(__mbstate_t))
        );
        fn test_field___mbstate8() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<__mbstate_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(__mbstate_t),
                    "::",
                    stringify!(__mbstate8)
                )
            );
        }
        test_field___mbstate8();
        fn test_field__mbstateL() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<__mbstate_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(__mbstate_t),
                    "::",
                    stringify!(_mbstateL)
                )
            );
        }
        test_field__mbstateL();
    }
    pub type __darwin_mbstate_t = __mbstate_t;
    pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
    pub type __darwin_size_t = ::std::os::raw::c_ulong;
    pub type __darwin_va_list = __builtin_va_list;
    pub type __darwin_wchar_t = ::std::os::raw::c_int;
    pub type __darwin_rune_t = __darwin_wchar_t;
    pub type __darwin_wint_t = ::std::os::raw::c_int;
    pub type __darwin_clock_t = ::std::os::raw::c_ulong;
    pub type __darwin_socklen_t = __uint32_t;
    pub type __darwin_ssize_t = ::std::os::raw::c_long;
    pub type __darwin_time_t = ::std::os::raw::c_long;
    pub type __darwin_blkcnt_t = __int64_t;
    pub type __darwin_blksize_t = __int32_t;
    pub type __darwin_dev_t = __int32_t;
    pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
    pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
    pub type __darwin_gid_t = __uint32_t;
    pub type __darwin_id_t = __uint32_t;
    pub type __darwin_ino64_t = __uint64_t;
    pub type __darwin_ino_t = __darwin_ino64_t;
    pub type __darwin_mach_port_name_t = __darwin_natural_t;
    pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
    pub type __darwin_mode_t = __uint16_t;
    pub type __darwin_off_t = __int64_t;
    pub type __darwin_pid_t = __int32_t;
    pub type __darwin_sigset_t = __uint32_t;
    pub type __darwin_suseconds_t = __int32_t;
    pub type __darwin_uid_t = __uint32_t;
    pub type __darwin_useconds_t = __uint32_t;
    pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
    pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __darwin_pthread_handler_rec {
        pub __routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        pub __arg: *mut ::core::ffi::c_void,
        pub __next: *mut __darwin_pthread_handler_rec,
    }
    #[test]
    fn bindgen_test_layout___darwin_pthread_handler_rec() {
        assert_eq!(
            ::core::mem::size_of::<__darwin_pthread_handler_rec>(),
            24usize,
            concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
        );
        assert_eq!(
            ::core::mem::align_of::<__darwin_pthread_handler_rec>(),
            8usize,
            concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
        );
        fn test_field___routine() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<__darwin_pthread_handler_rec>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(__darwin_pthread_handler_rec),
                    "::",
                    stringify!(__routine)
                )
            );
        }
        test_field___routine();
        fn test_field___arg() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<__darwin_pthread_handler_rec>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(__darwin_pthread_handler_rec),
                    "::",
                    stringify!(__arg)
                )
            );
        }
        test_field___arg();
        fn test_field___next() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<__darwin_pthread_handler_rec>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(__darwin_pthread_handler_rec),
                    "::",
                    stringify!(__next)
                )
            );
        }
        test_field___next();
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _opaque_pthread_attr_t {
        pub __sig: ::std::os::raw::c_long,
        pub __opaque: [::std::os::raw::c_char; 56usize],
    }
    #[test]
    fn bindgen_test_layout__opaque_pthread_attr_t() {
        assert_eq!(
            ::core::mem::size_of::<_opaque_pthread_attr_t>(),
            64usize,
            concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
        );
        assert_eq!(
            ::core::mem::align_of::<_opaque_pthread_attr_t>(),
            8usize,
            concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
        );
        fn test_field___sig() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_attr_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_attr_t),
                    "::",
                    stringify!(__sig)
                )
            );
        }
        test_field___sig();
        fn test_field___opaque() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_attr_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_attr_t),
                    "::",
                    stringify!(__opaque)
                )
            );
        }
        test_field___opaque();
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _opaque_pthread_cond_t {
        pub __sig: ::std::os::raw::c_long,
        pub __opaque: [::std::os::raw::c_char; 40usize],
    }
    #[test]
    fn bindgen_test_layout__opaque_pthread_cond_t() {
        assert_eq!(
            ::core::mem::size_of::<_opaque_pthread_cond_t>(),
            48usize,
            concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
        );
        assert_eq!(
            ::core::mem::align_of::<_opaque_pthread_cond_t>(),
            8usize,
            concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
        );
        fn test_field___sig() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_cond_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_cond_t),
                    "::",
                    stringify!(__sig)
                )
            );
        }
        test_field___sig();
        fn test_field___opaque() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_cond_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_cond_t),
                    "::",
                    stringify!(__opaque)
                )
            );
        }
        test_field___opaque();
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _opaque_pthread_condattr_t {
        pub __sig: ::std::os::raw::c_long,
        pub __opaque: [::std::os::raw::c_char; 8usize],
    }
    #[test]
    fn bindgen_test_layout__opaque_pthread_condattr_t() {
        assert_eq!(
            ::core::mem::size_of::<_opaque_pthread_condattr_t>(),
            16usize,
            concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
        );
        assert_eq!(
            ::core::mem::align_of::<_opaque_pthread_condattr_t>(),
            8usize,
            concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
        );
        fn test_field___sig() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_condattr_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_condattr_t),
                    "::",
                    stringify!(__sig)
                )
            );
        }
        test_field___sig();
        fn test_field___opaque() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_condattr_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_condattr_t),
                    "::",
                    stringify!(__opaque)
                )
            );
        }
        test_field___opaque();
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _opaque_pthread_mutex_t {
        pub __sig: ::std::os::raw::c_long,
        pub __opaque: [::std::os::raw::c_char; 56usize],
    }
    #[test]
    fn bindgen_test_layout__opaque_pthread_mutex_t() {
        assert_eq!(
            ::core::mem::size_of::<_opaque_pthread_mutex_t>(),
            64usize,
            concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
        );
        assert_eq!(
            ::core::mem::align_of::<_opaque_pthread_mutex_t>(),
            8usize,
            concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
        );
        fn test_field___sig() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_mutex_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_mutex_t),
                    "::",
                    stringify!(__sig)
                )
            );
        }
        test_field___sig();
        fn test_field___opaque() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_mutex_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_mutex_t),
                    "::",
                    stringify!(__opaque)
                )
            );
        }
        test_field___opaque();
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _opaque_pthread_mutexattr_t {
        pub __sig: ::std::os::raw::c_long,
        pub __opaque: [::std::os::raw::c_char; 8usize],
    }
    #[test]
    fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
        assert_eq!(
            ::core::mem::size_of::<_opaque_pthread_mutexattr_t>(),
            16usize,
            concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
        );
        assert_eq!(
            ::core::mem::align_of::<_opaque_pthread_mutexattr_t>(),
            8usize,
            concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
        );
        fn test_field___sig() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_mutexattr_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_mutexattr_t),
                    "::",
                    stringify!(__sig)
                )
            );
        }
        test_field___sig();
        fn test_field___opaque() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_mutexattr_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_mutexattr_t),
                    "::",
                    stringify!(__opaque)
                )
            );
        }
        test_field___opaque();
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _opaque_pthread_once_t {
        pub __sig: ::std::os::raw::c_long,
        pub __opaque: [::std::os::raw::c_char; 8usize],
    }
    #[test]
    fn bindgen_test_layout__opaque_pthread_once_t() {
        assert_eq!(
            ::core::mem::size_of::<_opaque_pthread_once_t>(),
            16usize,
            concat!("Size of: ", stringify!(_opaque_pthread_once_t))
        );
        assert_eq!(
            ::core::mem::align_of::<_opaque_pthread_once_t>(),
            8usize,
            concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
        );
        fn test_field___sig() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_once_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_once_t),
                    "::",
                    stringify!(__sig)
                )
            );
        }
        test_field___sig();
        fn test_field___opaque() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_once_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_once_t),
                    "::",
                    stringify!(__opaque)
                )
            );
        }
        test_field___opaque();
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _opaque_pthread_rwlock_t {
        pub __sig: ::std::os::raw::c_long,
        pub __opaque: [::std::os::raw::c_char; 192usize],
    }
    #[test]
    fn bindgen_test_layout__opaque_pthread_rwlock_t() {
        assert_eq!(
            ::core::mem::size_of::<_opaque_pthread_rwlock_t>(),
            200usize,
            concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
        );
        assert_eq!(
            ::core::mem::align_of::<_opaque_pthread_rwlock_t>(),
            8usize,
            concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
        );
        fn test_field___sig() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_rwlock_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_rwlock_t),
                    "::",
                    stringify!(__sig)
                )
            );
        }
        test_field___sig();
        fn test_field___opaque() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_rwlock_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_rwlock_t),
                    "::",
                    stringify!(__opaque)
                )
            );
        }
        test_field___opaque();
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _opaque_pthread_rwlockattr_t {
        pub __sig: ::std::os::raw::c_long,
        pub __opaque: [::std::os::raw::c_char; 16usize],
    }
    #[test]
    fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
        assert_eq!(
            ::core::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
            24usize,
            concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
        );
        assert_eq!(
            ::core::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
            8usize,
            concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
        );
        fn test_field___sig() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_rwlockattr_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_rwlockattr_t),
                    "::",
                    stringify!(__sig)
                )
            );
        }
        test_field___sig();
        fn test_field___opaque() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_rwlockattr_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_rwlockattr_t),
                    "::",
                    stringify!(__opaque)
                )
            );
        }
        test_field___opaque();
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _opaque_pthread_t {
        pub __sig: ::std::os::raw::c_long,
        pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
        pub __opaque: [::std::os::raw::c_char; 8176usize],
    }
    #[test]
    fn bindgen_test_layout__opaque_pthread_t() {
        assert_eq!(
            ::core::mem::size_of::<_opaque_pthread_t>(),
            8192usize,
            concat!("Size of: ", stringify!(_opaque_pthread_t))
        );
        assert_eq!(
            ::core::mem::align_of::<_opaque_pthread_t>(),
            8usize,
            concat!("Alignment of ", stringify!(_opaque_pthread_t))
        );
        fn test_field___sig() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_t),
                    "::",
                    stringify!(__sig)
                )
            );
        }
        test_field___sig();
        fn test_field___cleanup_stack() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_t),
                    "::",
                    stringify!(__cleanup_stack)
                )
            );
        }
        test_field___cleanup_stack();
        fn test_field___opaque() {
            assert_eq!(
                unsafe {
                    let uninit = ::core::mem::MaybeUninit::<_opaque_pthread_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_opaque_pthread_t),
                    "::",
                    stringify!(__opaque)
                )
            );
        }
        test_field___opaque();
    }
    pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
    pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
    pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
    pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
    pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
    pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
    pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
    pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
    pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
    pub type __darwin_pthread_t = *mut _opaque_pthread_t;
    pub type u_int8_t = ::std::os::raw::c_uchar;
    pub type u_int16_t = ::std::os::raw::c_ushort;
    pub type u_int32_t = ::std::os::raw::c_uint;
    pub type u_int64_t = ::std::os::raw::c_ulonglong;
    pub type register_t = i64;
    pub type user_addr_t = u_int64_t;
    pub type user_size_t = u_int64_t;
    pub type user_ssize_t = i64;
    pub type user_long_t = i64;
    pub type user_ulong_t = u_int64_t;
    pub type user_time_t = i64;
    pub type user_off_t = i64;
    pub type syscall_arg_t = u_int64_t;
    pub type intmax_t = ::std::os::raw::c_long;
    pub type uintmax_t = ::std::os::raw::c_ulong;
    pub mod agora {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod rtm {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod INIT_ERR_CODE {
                #[doc = "@brief Error codes related to Initialization."]
                pub type Type = u32;
                #[doc = "0: Initialization succeeds."]
                pub const INIT_ERR_OK: Type = 0;
                #[doc = "1: A common failure occurs during initialization."]
                pub const INIT_ERR_FAILURE: Type = 1;
                #[doc = "2: The SDK is already initialized."]
                pub const INIT_ERR_ALREADY_INITIALIZED: Type = 2;
                #[doc = "3: The App ID is invalid."]
                pub const INIT_ERR_INVALID_APP_ID: Type = 3;
                #[doc = "4: The event handler is empty."]
                pub const INIT_ERR_INVALID_ARGUMENT: Type = 4;
            }
            pub mod LOGIN_ERR_CODE {
                #[doc = "@brief Error codes related to login."]
                pub type Type = u32;
                #[doc = "0: The method call succeeds, or login succeeds."]
                pub const LOGIN_ERR_OK: Type = 0;
                #[doc = "1: Login fails. The reason is unknown."]
                pub const LOGIN_ERR_UNKNOWN: Type = 1;
                #[doc = "2: Login is rejected by the server."]
                pub const LOGIN_ERR_REJECTED: Type = 2;
                #[doc = "3: Invalid login argument."]
                pub const LOGIN_ERR_INVALID_ARGUMENT: Type = 3;
                #[doc = "4: The App ID is invalid."]
                pub const LOGIN_ERR_INVALID_APP_ID: Type = 4;
                #[doc = "5: The token is invalid."]
                pub const LOGIN_ERR_INVALID_TOKEN: Type = 5;
                #[doc = "6: The token has expired, and hence login is rejected."]
                pub const LOGIN_ERR_TOKEN_EXPIRED: Type = 6;
                #[doc = "7: Unauthorized login."]
                pub const LOGIN_ERR_NOT_AUTHORIZED: Type = 7;
                #[doc = "8: The user has already logged in or is logging in the Agora RTM system, or the user has not called the \\ref agora::rtm::IRtmService::logout \"logout\" method to leave the \\ref agora::rtm::CONNECTION_STATE_ABORTED \"CONNECTION_STATE_ABORTED\" state."]
                pub const LOGIN_ERR_ALREADY_LOGGED_IN: Type = 8;
                #[doc = "9: The login times out. The current timeout is set as 12 seconds. You need to log in again."]
                pub const LOGIN_ERR_TIMEOUT: Type = 9;
                #[doc = "10: The call frequency of the \\ref agora::rtm::IRtmService::login \"login\" method exceeds the limit of two queries per second."]
                pub const LOGIN_ERR_TOO_OFTEN: Type = 10;
                #[doc = "101: \\ref agora::rtm::IRtmService \"IRtmService\" is not initialized."]
                pub const LOGIN_ERR_NOT_INITIALIZED: Type = 101;
            }
            pub mod LOGOUT_ERR_CODE {
                #[doc = "@brief Error codes related to logout."]
                pub type Type = u32;
                #[doc = "0: The method call succeeds, or logout succeeds."]
                pub const LOGOUT_ERR_OK: Type = 0;
                #[doc = "1: **RESERVED FOR FUTURE USE**"]
                pub const LOGOUT_ERR_REJECTED: Type = 1;
                #[doc = "101: \\ref agora::rtm::IRtmService \"IRtmService\" is not initialized."]
                pub const LOGOUT_ERR_NOT_INITIALIZED: Type = 101;
                #[doc = "102: The user does not call the \\ref agora::rtm::IRtmService::login \"login\" method, or the method call of \\ref agora::rtm::IRtmService::login \"login\" does not succeed before the user logs out of the Agora RTM system."]
                pub const LOGOUT_ERR_USER_NOT_LOGGED_IN: Type = 102;
            }
            pub mod RENEW_TOKEN_ERR_CODE {
                #[doc = "@brief Error codes related to renewing the RTM Token."]
                pub type Type = u32;
                #[doc = "0: The method call succeeds, or the renewing operation succeeds."]
                pub const RENEW_TOKEN_ERR_OK: Type = 0;
                #[doc = "1: Common failure. The user fails to renew the token."]
                pub const RENEW_TOKEN_ERR_FAILURE: Type = 1;
                #[doc = "2: The method call fails. The argument is invalid."]
                pub const RENEW_TOKEN_ERR_INVALID_ARGUMENT: Type = 2;
                #[doc = "3: **RESERVED FOR FUTURE USE**"]
                pub const RENEW_TOKEN_ERR_REJECTED: Type = 3;
                #[doc = "4: The method call frequency exceeds the limit of two queries per second."]
                pub const RENEW_TOKEN_ERR_TOO_OFTEN: Type = 4;
                #[doc = "5: The token has expired."]
                pub const RENEW_TOKEN_ERR_TOKEN_EXPIRED: Type = 5;
                #[doc = "6: The token is invalid."]
                pub const RENEW_TOKEN_ERR_INVALID_TOKEN: Type = 6;
                #[doc = "101: \\ref agora::rtm::IRtmService \"IRtmService\" is not initialized."]
                pub const RENEW_TOKEN_ERR_NOT_INITIALIZED: Type = 101;
                #[doc = "102: The user does not call the \\ref agora::rtm::IRtmService::login \"login\" method, or the method call of \\ref agora::rtm::IRtmService::login \"login\" does not succeed before renewing the token."]
                pub const RENEW_TOKEN_ERR_USER_NOT_LOGGED_IN: Type = 102;
            }
            pub mod CONNECTION_STATE {
                #[doc = "@brief Connection states between the SDK and the Agora RTM system."]
                pub type Type = u32;
                #[doc = "1: The initial state. The SDK is disconnected from the Agora RTM system."]
                #[doc = ""]
                #[doc = "When the user calls the \\ref agora::rtm::IRtmService::login \"login\" method, the SDK starts to log in the Agora RTM system, triggers the \\ref agora::rtm::IRtmServiceEventHandler::onConnectionStateChanged \"onConnectionStateChanged\" callback, and switches to the \\ref agora::rtm::CONNECTION_STATE_CONNECTING \"CONNECTION_STATE_CONNECTING\" state."]
                pub const CONNECTION_STATE_DISCONNECTED: Type = 1;
                #[doc = "2: The SDK is logging in the Agora RTM system."]
                #[doc = ""]
                #[doc = "- If the user successfully logs in the Agora RTM system and receives the \\ref agora::rtm::IRtmServiceEventHandler::onLoginSuccess \"onLoginSuccess\" callback, the SDK triggers the \\ref agora::rtm::IRtmServiceEventHandler::onConnectionStateChanged \"onConnectionStateChanged\" callback and switches to the \\ref agora::rtm::CONNECTION_STATE_CONNECTED \"CONNECTION_STATE_CONNECTED\" state."]
                #[doc = "- If the user fails to login the Agora RTM system and receives the \\ref agora::rtm::IRtmServiceEventHandler::onLoginFailure \"onLoginFailure\" callback, the SDK triggers the \\ref agora::rtm::IRtmServiceEventHandler::onConnectionStateChanged \"onConnectionStateChanged\" callback and switches to the \\ref agora::rtm::CONNECTION_STATE_DISCONNECTED \"CONNECTION_STATE_DISCONNECTED\" state."]
                pub const CONNECTION_STATE_CONNECTING: Type = 2;
                #[doc = "3: The SDK has logged in the Agora RTM system."]
                #[doc = ""]
                #[doc = "- If the connection state between the SDK and the Agora RTM system is interrupted because of network issues, the SDK triggers the \\ref agora::rtm::IRtmServiceEventHandler::onConnectionStateChanged \"onConnectionStateChanged\" callback and switches to the \\ref agora::rtm::CONNECTION_STATE_RECONNECTING \"CONNECTION_STATE_RECONNECTING\" state."]
                #[doc = "- If the login is banned by the server because, for example, another instance logs in the Agora RTM system with the same user ID, the \\ref agora::rtm::IRtmServiceEventHandler::onConnectionStateChanged \"onConnectionStateChanged\" callback is triggered, and the SDK is switched to the \\ref agora::rtm::CONNECTION_STATE_ABORTED \"CONNECTION_STATE_ABORTED\" state."]
                #[doc = "- If the user calls the \\ref agora::rtm::IRtmService::logout \"logout\" method to log out of the Agora RTM system and receives the \\ref agora::rtm::IRtmServiceEventHandler::onLogout \"onLogout\" callback (error code = `LOGOUT_ERR_OK`), the SDK triggers the \\ref agora::rtm::IRtmServiceEventHandler::onConnectionStateChanged \"onConnectionStateChanged\" callback and switches to the \\ref agora::rtm::CONNECTION_STATE_DISCONNECTED \"CONNECTION_STATE_DISCONNECTED\" state."]
                pub const CONNECTION_STATE_CONNECTED: Type = 3;
                #[doc = "4: The connection state between the SDK and the Agora RTM system is interrupted due to network issues, and the SDK keeps re-logging in the Agora RTM system."]
                #[doc = ""]
                #[doc = "- If the SDK successfully re-logs in the Agora RTM system, the SDK triggers the \\ref agora::rtm::IRtmServiceEventHandler::onConnectionStateChanged \"onConnectionStateChanged\" callback and switches to the \\ref agora::rtm::CONNECTION_STATE_CONNECTED \"CONNECTION_STATE_CONNECTED\" state. The SDK automatically adds the user back to the channels he or she was in when the connection was interrupted, and synchronizes the local user's attributes with the server."]
                #[doc = "- If the SDK cannot re-log in the Agora RTM system, it stays in the \\ref agora::rtm::CONNECTION_STATE_RECONNECTING \"CONNECTION_STATE_RECONNECTING\" state and keeps re-logging in the system."]
                pub const CONNECTION_STATE_RECONNECTING: Type = 4;
                #[doc = "5: The SDK gives up logging in the Agora RTM system, mainly because another instance has logged in the Agora RTM system with the same user ID."]
                #[doc = ""]
                #[doc = "You must call the \\ref agora::rtm::IRtmService::logout \"logout\" method to leave this state before calling the \\ref agora::rtm::IRtmService::login \"login\" method again."]
                pub const CONNECTION_STATE_ABORTED: Type = 5;
            }
            pub mod CONNECTION_CHANGE_REASON {
                #[doc = "@brief Reasons for a connection state change."]
                pub type Type = u32;
                #[doc = "1: The SDK is logging in the Agora RTM system."]
                pub const CONNECTION_CHANGE_REASON_LOGIN: Type = 1;
                #[doc = "2: The SDK has logged in the Agora RTM system."]
                pub const CONNECTION_CHANGE_REASON_LOGIN_SUCCESS: Type = 2;
                #[doc = "3: The SDK fails to log in the Agora RTM system."]
                pub const CONNECTION_CHANGE_REASON_LOGIN_FAILURE: Type = 3;
                #[doc = "4: The SDK fails to log in the Agora RTM system within 12 seconds and gives up."]
                pub const CONNECTION_CHANGE_REASON_LOGIN_TIMEOUT: Type = 4;
                #[doc = "5: The connection between the SDK and the Agora RTM system is interrupted. The system defines an interruption when the SDK loses connection with the Agora RTM system for network reasons and cannot recover in four seconds."]
                pub const CONNECTION_CHANGE_REASON_INTERRUPTED: Type = 5;
                #[doc = "6: The user has called the \\ref agora::rtm::IRtmService::logout \"logout\" method to log out of the Agora RTM system."]
                pub const CONNECTION_CHANGE_REASON_LOGOUT: Type = 6;
                #[doc = "7: The SDK login to the Agora RTM system is banned by Agora."]
                pub const CONNECTION_CHANGE_REASON_BANNED_BY_SERVER: Type = 7;
                #[doc = "8: Another user is logging in the Agora RTM system with the same User ID."]
                pub const CONNECTION_CHANGE_REASON_REMOTE_LOGIN: Type = 8;
                #[doc = "9: The token has expired."]
                pub const CONNECTION_CHANGE_REASON_TOKEN_EXPIRED: Type = 9;
            }
            pub mod PEER_MESSAGE_ERR_CODE {
                #[doc = "@brief Error codes related to sending a peer-to-peer message."]
                pub type Type = u32;
                #[doc = "0: The method call succeeds, or the specified user receives the peer-to-peer message."]
                pub const PEER_MESSAGE_ERR_OK: Type = 0;
                #[doc = "1: The sender fails to send the peer-to-peer message."]
                pub const PEER_MESSAGE_ERR_FAILURE: Type = 1;
                #[doc = "2: A timeout occurs when sending the peer-to-peer message. The current timeout is set as 10 seconds. Possible reasons: The user is in the \\ref agora::rtm::CONNECTION_STATE_ABORTED \"CONNECTION_STATE_ABORTED\" or \\ref agora::rtm::CONNECTION_STATE_RECONNECTING \"CONNECTION_STATE_RECONNECTING\" state."]
                pub const PEER_MESSAGE_ERR_SENT_TIMEOUT: Type = 2;
                #[doc = "3: The specified user is offline and does not receive this peer-to-peer message."]
                pub const PEER_MESSAGE_ERR_PEER_UNREACHABLE: Type = 3;
                #[doc = "4: The receiver is offline and does not receive this offline peer-to-peer message, but the server has cached it and will re-send it once he/she is back online."]
                pub const PEER_MESSAGE_ERR_CACHED_BY_SERVER: Type = 4;
                #[doc = "5: The method call frequency exceeds the limit of (RTM SDK for Windows C++) 180 calls every three seconds or (RTM SDK for Linux C++) 1500 calls every three seconds, with channel and peer messages taken together.."]
                pub const PEER_MESSAGE_ERR_TOO_OFTEN: Type = 5;
                #[doc = "6: The user ID is invalid."]
                pub const PEER_MESSAGE_ERR_INVALID_USERID: Type = 6;
                #[doc = "7: The message is null or exceeds 32 KB in length."]
                pub const PEER_MESSAGE_ERR_INVALID_MESSAGE: Type = 7;
                #[doc = "8: The message receiverâ€˜s SDK is of an earlier version and hence cannot recognize this message."]
                pub const PEER_MESSAGE_ERR_IMCOMPATIBLE_MESSAGE: Type = 8;
                #[doc = "101: \\ref agora::rtm::IRtmService \"IRtmService\" is not initialized."]
                pub const PEER_MESSAGE_ERR_NOT_INITIALIZED: Type = 101;
                #[doc = "102: The sender does not call the \\ref agora::rtm::IRtmService::login \"login\" method, or the method call of \\ref agora::rtm::IRtmService::login \"login\" does not succeed before sending the peer-to-peer message."]
                pub const PEER_MESSAGE_ERR_USER_NOT_LOGGED_IN: Type = 102;
            }
            pub mod JOIN_CHANNEL_ERR {
                #[doc = "@brief Error codes related to joining a channel."]
                pub type Type = u32;
                #[doc = "0: The method call succeeds, or the user joins the channel successfully."]
                pub const JOIN_CHANNEL_ERR_OK: Type = 0;
                #[doc = "1: Common failure. The user fails to join the channel."]
                pub const JOIN_CHANNEL_ERR_FAILURE: Type = 1;
                #[doc = "2: For v1.0.0 and earlier, the SDK returns this error when you try to join a channel that you have already joined. The SDK does not return this error code after v1.0.0."]
                pub const JOIN_CHANNEL_ERR_REJECTED: Type = 2;
                #[doc = "3: The user fails to join the channel because the argument is invalid."]
                pub const JOIN_CHANNEL_ERR_INVALID_ARGUMENT: Type = 3;
                #[doc = "4: A timeout occurs when joining the channel. The current timeout is set as five seconds. Possible reasons: The user is in the \\ref agora::rtm::CONNECTION_STATE_ABORTED \"CONNECTION_STATE_ABORTED\" or \\ref agora::rtm::CONNECTION_STATE_RECONNECTING \"CONNECTION_STATE_RECONNECTING\" state."]
                pub const JOIN_CHANNEL_TIMEOUT: Type = 4;
                #[doc = "5: The number of the RTM channels you are in exceeds the limit of 20."]
                pub const JOIN_CHANNEL_ERR_EXCEED_LIMIT: Type = 5;
                #[doc = "6: The user is joining or has joined the channel."]
                pub const JOIN_CHANNEL_ERR_ALREADY_JOINED: Type = 6;
                #[doc = "7: The method call frequency exceeds 50 queries every three seconds."]
                pub const JOIN_CHANNEL_ERR_TOO_OFTEN: Type = 7;
                #[doc = "8: The frequency of joining the same channel exceeds two times every five seconds."]
                pub const JOIN_CHANNEL_ERR_JOIN_SAME_CHANNEL_TOO_OFTEN: Type = 8;
                #[doc = "101: \\ref agora::rtm::IRtmService \"IRtmService\" is not initialized."]
                pub const JOIN_CHANNEL_ERR_NOT_INITIALIZED: Type = 101;
                #[doc = "102: The user does not call the \\ref agora::rtm::IRtmService::login \"login\" method, or the method call of \\ref agora::rtm::IRtmService::login \"login\" does not succeed before joining the channel."]
                pub const JOIN_CHANNEL_ERR_USER_NOT_LOGGED_IN: Type = 102;
            }
            pub mod LEAVE_CHANNEL_ERR {
                #[doc = "@brief Error codes related to leaving a channel."]
                pub type Type = u32;
                #[doc = "0: The method call succeeds, or the user leaves the channel successfully."]
                pub const LEAVE_CHANNEL_ERR_OK: Type = 0;
                #[doc = "1: Common failure. The user fails to leave the channel."]
                pub const LEAVE_CHANNEL_ERR_FAILURE: Type = 1;
                #[doc = "2: **RESERVED FOR FUTURE USE**"]
                pub const LEAVE_CHANNEL_ERR_REJECTED: Type = 2;
                #[doc = "3: The user is not in the channel."]
                pub const LEAVE_CHANNEL_ERR_NOT_IN_CHANNEL: Type = 3;
                #[doc = "4: The user is banned to join the channel."]
                pub const LEAVE_CHANNEL_ERR_KICKED: Type = 4;
                #[doc = "101: \\ref agora::rtm::IRtmService \"IRtmService\" is not initialized."]
                pub const LEAVE_CHANNEL_ERR_NOT_INITIALIZED: Type = 101;
                #[doc = "102: The user does not call the \\ref agora::rtm::IRtmService::login \"login\" method, or the method call of \\ref agora::rtm::IRtmService::login \"login\" does not succeed before calling the \\ref agora::rtm::IChannel::leave \"leave\" method."]
                pub const LEAVE_CHANNEL_ERR_USER_NOT_LOGGED_IN: Type = 102;
            }
            pub mod LEAVE_CHANNEL_REASON {
                #[doc = "@brief Reasons why a user leaves the channel."]
                pub type Type = u32;
                #[doc = "1: The user has quit the call."]
                pub const LEAVE_CHANNEL_REASON_QUIT: Type = 1;
                #[doc = "2: The user is banned by the server."]
                pub const LEAVE_CHANNEL_REASON_KICKED: Type = 2;
            }
            pub mod CHANNEL_MESSAGE_ERR_CODE {
                #[doc = "@brief Error codes related to sending a channel message."]
                pub type Type = u32;
                #[doc = "0: The method call succeeds, or the server receives the channel message."]
                pub const CHANNEL_MESSAGE_ERR_OK: Type = 0;
                #[doc = "1: Common failure. The user fails to send the channel message."]
                pub const CHANNEL_MESSAGE_ERR_FAILURE: Type = 1;
                #[doc = "2: The SDK does not receive a response from the server in 10 seconds. The current timeout is set as 10 seconds. Possible reasons: The user is in the \\ref agora::rtm::CONNECTION_STATE_ABORTED \"CONNECTION_STATE_ABORTED\" or \\ref agora::rtm::CONNECTION_STATE_RECONNECTING \"CONNECTION_STATE_RECONNECTING\" state."]
                pub const CHANNEL_MESSAGE_ERR_SENT_TIMEOUT: Type = 2;
                #[doc = "3: The method call frequency exceeds the limit of (RTM SDK for Windows C++) 180 calls every three seconds or (RTM SDK for Linux C++) 1500 calls every three seconds, with channel and peer messages taken together.."]
                pub const CHANNEL_MESSAGE_ERR_TOO_OFTEN: Type = 3;
                #[doc = "4: The message is null or exceeds 32 KB in length."]
                pub const CHANNEL_MESSAGE_ERR_INVALID_MESSAGE: Type = 4;
                #[doc = "101: \\ref agora::rtm::IRtmService \"IRtmService\" is not initialized."]
                pub const CHANNEL_MESSAGE_ERR_NOT_INITIALIZED: Type = 101;
                #[doc = "102: The user does not call the \\ref agora::rtm::IRtmService::login \"login\" method, or the method call of \\ref agora::rtm::IRtmService::login \"login\" does not succeed before sending out a channel message."]
                pub const CHANNEL_MESSAGE_ERR_USER_NOT_LOGGED_IN: Type = 102;
            }
            pub mod GET_MEMBERS_ERR {
                #[doc = "@brief Error codes related to retrieving a channel member list."]
                pub type Type = u32;
                #[doc = "0: The method call succeeds, or the operation succeeds."]
                pub const GET_MEMBERS_ERR_OK: Type = 0;
                #[doc = "1: Common failure. The user fails to retrieve a member list of the channel."]
                pub const GET_MEMBERS_ERR_FAILURE: Type = 1;
                #[doc = "2: **RESERVED FOR FUTURE USE**"]
                pub const GET_MEMBERS_ERR_REJECTED: Type = 2;
                #[doc = "3: A timeout occurs when retrieving a member list of the channel. The current timeout is set as five seconds. Possible reasons: The user is in the \\ref agora::rtm::CONNECTION_STATE_ABORTED \"CONNECTION_STATE_ABORTED\" or \\ref agora::rtm::CONNECTION_STATE_RECONNECTING \"CONNECTION_STATE_RECONNECTING\" state."]
                pub const GET_MEMBERS_ERR_TIMEOUT: Type = 3;
                #[doc = "4: The method call frequency exceeds the limit of five queries every two seconds."]
                pub const GET_MEMBERS_ERR_TOO_OFTEN: Type = 4;
                #[doc = "5: The user is not in channel."]
                pub const GET_MEMBERS_ERR_NOT_IN_CHANNEL: Type = 5;
                #[doc = "101: \\ref agora::rtm::IRtmService \"IRtmService\" is not initialized."]
                pub const GET_MEMBERS_ERR_NOT_INITIALIZED: Type = 101;
                #[doc = "102: The user does not call the \\ref agora::rtm::IRtmService::login \"login\" method, or the method call of \\ref agora::rtm::IRtmService::login \"login\" does not succeed before retrieving a member list."]
                pub const GET_MEMBERS_ERR_USER_NOT_LOGGED_IN: Type = 102;
            }
            pub mod QUERY_PEERS_ONLINE_STATUS_ERR {
                #[doc = "@brief Error codes related to querying the online status of the specified peers."]
                pub type Type = u32;
                #[doc = "0: The method call succeeds, or the operation succeeds."]
                pub const QUERY_PEERS_ONLINE_STATUS_ERR_OK: Type = 0;
                #[doc = "1: Common failure. The user fails to query the online status of the specified peers."]
                pub const QUERY_PEERS_ONLINE_STATUS_ERR_FAILURE: Type = 1;
                #[doc = "2: The method call fails. The argument is invalid."]
                pub const QUERY_PEERS_ONLINE_STATUS_ERR_INVALID_ARGUMENT: Type = 2;
                #[doc = "3: **RESERVED FOR FUTURE USE**"]
                pub const QUERY_PEERS_ONLINE_STATUS_ERR_REJECTED: Type = 3;
                #[doc = "4: The SDK fails to receive a response from the server in 10 seconds. The current timeout is set as 10 seconds. Possible reasons: The user is in the \\ref agora::rtm::CONNECTION_STATE_ABORTED \"CONNECTION_STATE_ABORTED\" or \\ref agora::rtm::CONNECTION_STATE_RECONNECTING \"CONNECTION_STATE_RECONNECTING\" state."]
                pub const QUERY_PEERS_ONLINE_STATUS_ERR_TIMEOUT: Type = 4;
                #[doc = "5: The method call frequency exceeds the limit of (RTM SDK for Windows C++) 10 calls every five seconds or (RTM SDK for Linux C++) 100 calls every five seconds."]
                pub const QUERY_PEERS_ONLINE_STATUS_ERR_TOO_OFTEN: Type = 5;
                #[doc = "101: \\ref agora::rtm::IRtmService \"IRtmService\" is not initialized."]
                pub const QUERY_PEERS_ONLINE_STATUS_ERR_NOT_INITIALIZED: Type = 101;
                #[doc = "102: The user does not call the \\ref agora::rtm::IRtmService::login \"login\" method, or the method call of \\ref agora::rtm::IRtmService::login \"login\" does not succeed before querying the online status."]
                pub const QUERY_PEERS_ONLINE_STATUS_ERR_USER_NOT_LOGGED_IN: Type = 102;
            }
            pub mod PEER_ONLINE_STATE {
                #[doc = "@brief The online states of a peer."]
                pub type Type = u32;
                #[doc = "0: The peer is online (the SDK has logged in the Agora RTM system)."]
                pub const PEER_ONLINE_STATE_ONLINE: Type = 0;
                #[doc = "1: The peer is temporarily unreachable (the server has not received a packet from the SDK for more than six seconds)."]
                pub const PEER_ONLINE_STATE_UNREACHABLE: Type = 1;
                #[doc = "2: The peer is offline (the SDK has not logged in the Agora RTM system, or it has logged out of the system, or the server has not received a packet from the SDK for more than 30 seconds)."]
                pub const PEER_ONLINE_STATE_OFFLINE: Type = 2;
            }
            pub mod PEER_SUBSCRIPTION_OPTION {
                #[doc = "@brief Subscription types."]
                pub type Type = u32;
                #[doc = "0: Takes out a subscription to the online status of specified users."]
                pub const PEER_SUBSCRIPTION_OPTION_ONLINE_STATUS: Type = 0;
            }
            pub mod PEER_SUBSCRIPTION_STATUS_ERR {
                #[doc = "@brief Error codes related to subscribing to or unsubscribing from the status of specified peers."]
                pub type Type = u32;
                #[doc = "0: The method call succeeds, or the operation succeeds."]
                pub const PEER_SUBSCRIPTION_STATUS_ERR_OK: Type = 0;
                #[doc = "1: Common failure. The user fails to subscribe to or unsubscribe from the status of the specified peers."]
                pub const PEER_SUBSCRIPTION_STATUS_ERR_FAILURE: Type = 1;
                #[doc = "2: The method call fails. The argument is invalid."]
                pub const PEER_SUBSCRIPTION_STATUS_ERR_INVALID_ARGUMENT: Type = 2;
                #[doc = "3: **RESERVED FOR FUTURE USE**"]
                pub const PEER_SUBSCRIPTION_STATUS_ERR_REJECTED: Type = 3;
                #[doc = "4: The SDK fails to receive a response from the server within 10 seconds. The current timeout is set as 10 seconds. Possible reasons: The user is in the \\ref agora::rtm::CONNECTION_STATE_ABORTED \"CONNECTION_STATE_ABORTED\" or \\ref agora::rtm::CONNECTION_STATE_RECONNECTING \"CONNECTION_STATE_RECONNECTING\" state."]
                pub const PEER_SUBSCRIPTION_STATUS_ERR_TIMEOUT: Type = 4;
                #[doc = "5: The method call frequency exceeds the limit of 10 queries every five seconds."]
                pub const PEER_SUBSCRIPTION_STATUS_ERR_TOO_OFTEN: Type = 5;
                #[doc = "6: The number of peers, to whom you subscribe, exceeds the limit of 512."]
                pub const PEER_SUBSCRIPTION_STATUS_ERR_OVERFLOW: Type = 6;
                #[doc = "101: \\ref agora::rtm::IRtmService \"IRtmService\" is not initialized."]
                pub const PEER_SUBSCRIPTION_STATUS_ERR_NOT_INITIALIZED: Type = 101;
                #[doc = "102: The user does not call the \\ref agora::rtm::IRtmService::login \"login\" method, or the method call of \\ref agora::rtm::IRtmService::login \"login\" does not succeed before this operation."]
                pub const PEER_SUBSCRIPTION_STATUS_ERR_USER_NOT_LOGGED_IN: Type = 102;
            }
            pub mod QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR {
                #[doc = "@brief Error codes related to getting a list of the peers by subscription option type."]
                pub type Type = u32;
                #[doc = "0: The method call succeeds, or the operation succeeds."]
                pub const QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_OK: Type = 0;
                #[doc = "1: Common failure. The user fails to query peers by subscription option type."]
                pub const QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_FAILURE: Type = 1;
                #[doc = "2: The SDK fails to receive a response from the server within 5 seconds. The current timeout is set as 5 seconds. Possible reasons: The user is in the \\ref agora::rtm::CONNECTION_STATE_ABORTED \"CONNECTION_STATE_ABORTED\" or \\ref agora::rtm::CONNECTION_STATE_RECONNECTING \"CONNECTION_STATE_RECONNECTING\" state."]
                pub const QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_TIMEOUT: Type = 2;
                #[doc = "3: The method call frequency exceeds the limit of 10 queries every five seconds."]
                pub const QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_TOO_OFTEN: Type = 3;
                #[doc = "101: \\ref agora::rtm::IRtmService \"IRtmService\" is not initialized."]
                pub const QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_NOT_INITIALIZED: Type = 101;
                #[doc = "102: The user does not call the \\ref agora::rtm::IRtmService::login \"login\" method, or the method call of \\ref agora::rtm::IRtmService::login \"login\" does not succeed before the query."]
                pub const QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_USER_NOT_LOGGED_IN: Type = 102;
            }
            pub mod ATTRIBUTE_OPERATION_ERR {
                #[doc = "@brief Error codes related to attrubute operations."]
                pub type Type = u32;
                #[doc = "0: The method call succeeds, or the attribute operation succeeds."]
                pub const ATTRIBUTE_OPERATION_ERR_OK: Type = 0;
                #[doc = "1: @deprecated"]
                pub const ATTRIBUTE_OPERATION_ERR_NOT_READY: Type = 1;
                #[doc = "2: Common failure. The attribute operation fails."]
                pub const ATTRIBUTE_OPERATION_ERR_FAILURE: Type = 2;
                #[doc = "3: The argument you put for this attribute operation is invalid. For example, you cannot set a user or channel attribute as \"\"."]
                pub const ATTRIBUTE_OPERATION_ERR_INVALID_ARGUMENT: Type = 3;
                #[doc = "4: The attribute size exceeds the limit."]
                #[doc = ""]
                #[doc = "- For user attribute operations: The user's overall attribute size would exceed the limit of 16 KB, one of the user's attributes would exceeds 8 KB in size, or the number of this user's attributes would exceed 32 after this attribute operation."]
                #[doc = "- For channel attribute operations: The channel's overall attribute size would exceed the limit of 32 KB, one of the channel attributes would exceed 8 KB in size, or the number of this channel's attributes would exceed 32 after this attribute operation."]
                pub const ATTRIBUTE_OPERATION_ERR_SIZE_OVERFLOW: Type = 4;
                #[doc = "5: The method call frequency exceeds the limit."]
                #[doc = ""]
                #[doc = "- For \\ref agora::rtm::IRtmService::setLocalUserAttributes \"setLocalUserAttributes\", \\ref agora::rtm::IRtmService::addOrUpdateLocalUserAttributes \"addOrUpdateLocalUserAttributes\", \\ref agora::rtm::IRtmService::deleteLocalUserAttributesByKeys \"deleteLocalUserAttributesByKeys\" and \\ref agora::rtm::IRtmService::clearLocalUserAttributes \"clearLocalUserAttributes\" taken together: the maximum call frequency is (RTM SDK for Windows C++) 10 calls every five seconds or (RTM SDK for Linux C++) 100 calls every five seconds."]
                #[doc = "- For \\ref agora::rtm::IRtmService::getUserAttributes \"getUserAttributes\" and \\ref agora::rtm::IRtmService::getUserAttributesByKeys \"getUserAttributesByKeys\" taken together, the maximum call frequency is (RTM SDK for Windows C++) 40 calls every five seconds or (RTM SDK for Linux C++) 400 calls every five seconds."]
                #[doc = "- For \\ref agora::rtm::IRtmService::setChannelAttributes \"setChannelAttributes\", \\ref agora::rtm::IRtmService::addOrUpdateChannelAttributes \"addOrUpdateChannelAttributes\", \\ref agora::rtm::IRtmService::deleteChannelAttributesByKeys \"deleteChannelAttributesByKeys\" and \\ref agora::rtm::IRtmService::clearChannelAttributes \"clearChannelAttributes\" taken together: the maximum call frequency is (RTM SDK for Windows C++) 10 calls every five seconds or (RTM SDK for Linux C++) 100 calls every five seconds."]
                #[doc = "- For \\ref agora::rtm::IRtmService::getChannelAttributes \"getChannelAttributes\" and \\ref agora::rtm::IRtmService::getChannelAttributesByKeys \"getChannelAttributesByKeys\" taken together, the maximum call frequency is (RTM SDK for Windows C++) 10 calls every five seconds or (RTM SDK for Linux C++) 400 calls every five seconds."]
                pub const ATTRIBUTE_OPERATION_ERR_TOO_OFTEN: Type = 5;
                #[doc = "6: The specified user is not found, either because the user is offline or because the user does not exist."]
                pub const ATTRIBUTE_OPERATION_ERR_USER_NOT_FOUND: Type = 6;
                #[doc = "7: A timeout occurs during the attribute operation. The current timeout is set as five seconds. Possible reasons: The user is in the \\ref agora::rtm::CONNECTION_STATE_ABORTED \"CONNECTION_STATE_ABORTED\" or \\ref agora::rtm::CONNECTION_STATE_RECONNECTING \"CONNECTION_STATE_RECONNECTING\" state."]
                pub const ATTRIBUTE_OPERATION_ERR_TIMEOUT: Type = 7;
                #[doc = "101: \\ref agora::rtm::IRtmService \"IRtmService\" is not initialized."]
                pub const ATTRIBUTE_OPERATION_ERR_NOT_INITIALIZED: Type = 101;
                #[doc = "102: The user does not call the \\ref agora::rtm::IRtmService::login \"login\" method, or the method call of \\ref agora::rtm::IRtmService::login \"login\" does not succeed before the attribute operation."]
                pub const ATTRIBUTE_OPERATION_ERR_USER_NOT_LOGGED_IN: Type = 102;
            }
            pub mod GET_CHANNEL_MEMBER_COUNT_ERR_CODE {
                #[doc = "@brief Error codes related to retrieving the channel member count of specified channels."]
                pub type Type = u32;
                #[doc = "0: The method call succeeds, or the operation succeeds."]
                pub const GET_CHANNEL_MEMBER_COUNT_ERR_OK: Type = 0;
                #[doc = "1: Unknown common failure."]
                pub const GET_CHANNEL_MEMBER_COUNT_ERR_FAILURE: Type = 1;
                #[doc = "2: One or several of your channel IDs is invalid, or @p channelCount &lt; 0."]
                pub const GET_CHANNEL_MEMBER_COUNT_ERR_INVALID_ARGUMENT: Type = 2;
                #[doc = "3: The method call frequency exceeds the limit of one query per second."]
                pub const GET_CHANNEL_MEMBER_COUNT_ERR_TOO_OFTEN: Type = 3;
                #[doc = "4: A timeout occurs during this operation. The current timeout is set as five seconds."]
                pub const GET_CHANNEL_MEMBER_COUNT_ERR_TIMEOUT: Type = 4;
                #[doc = "5:@p channelCount is greater than 32."]
                pub const GET_CHANNEL_MEMBER_COUNT_ERR_EXCEED_LIMIT: Type = 5;
                #[doc = "101: \\ref agora::rtm::IRtmService \"IRtmService\" is not initialized."]
                pub const GET_CHANNEL_MEMBER_COUNT_ERR_NOT_INITIALIZED: Type = 101;
                #[doc = "102: The user does not call the \\ref agora::rtm::IRtmService::login \"login\" method, or the method call of \\ref agora::rtm::IRtmService::login \"login\" does not succeed before this operation."]
                pub const GET_CHANNEL_MEMBER_COUNT_ERR_USER_NOT_LOGGED_IN: Type = 102;
            }
            pub mod MESSAGE_TYPE {
                #[doc = "@brief Message types."]
                pub type Type = u32;
                #[doc = "0: The message type is undefined."]
                pub const MESSAGE_TYPE_UNDEFINED: Type = 0;
                #[doc = "1: A text message."]
                pub const MESSAGE_TYPE_TEXT: Type = 1;
                #[doc = "2: A raw message. A raw message is a binary message whose size does not exceed 32 KB."]
                pub const MESSAGE_TYPE_RAW: Type = 2;
                #[doc = "3: A file message. The size of a file message must be less than 32 KB."]
                pub const MESSAGE_TYPE_FILE: Type = 3;
                #[doc = "4: An image message. The size of an image message must be less than 32 KB."]
                pub const MESSAGE_TYPE_IMAGE: Type = 4;
            }
            #[doc = "@brief Message sending options."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SendMessageOptions {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_SendMessageOptions() {
                assert_eq!(
                    ::core::mem::size_of::<SendMessageOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(SendMessageOptions))
                );
                assert_eq!(
                    ::core::mem::align_of::<SendMessageOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SendMessageOptions))
                );
            }
            #[doc = "@brief A data structure holding a user attribute key and its value."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct RtmAttribute {
                #[doc = "User attribute name. Must be visible characters and not exceed 32 Bytes."]
                pub key: *const ::std::os::raw::c_char,
                #[doc = "Value of the user attribute. Must not exceed 8 KB."]
                pub value: *const ::std::os::raw::c_char,
            }
            #[test]
            fn bindgen_test_layout_RtmAttribute() {
                assert_eq!(
                    ::core::mem::size_of::<RtmAttribute>(),
                    16usize,
                    concat!("Size of: ", stringify!(RtmAttribute))
                );
                assert_eq!(
                    ::core::mem::align_of::<RtmAttribute>(),
                    8usize,
                    concat!("Alignment of ", stringify!(RtmAttribute))
                );
                fn test_field_key() {
                    assert_eq!(
                        unsafe {
                            let uninit = ::core::mem::MaybeUninit::<RtmAttribute>::uninit();
                            let ptr = uninit.as_ptr();
                            ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RtmAttribute),
                            "::",
                            stringify!(key)
                        )
                    );
                }
                test_field_key();
                fn test_field_value() {
                    assert_eq!(
                        unsafe {
                            let uninit = ::core::mem::MaybeUninit::<RtmAttribute>::uninit();
                            let ptr = uninit.as_ptr();
                            ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize
                        },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RtmAttribute),
                            "::",
                            stringify!(value)
                        )
                    );
                }
                test_field_value();
            }
            #[repr(C)]
            pub struct IRtmChannelAttribute__bindgen_vtable {
                pub setKey: unsafe extern "C" fn(
                    this: *mut IRtmChannelAttribute,
                    key: *const ::std::os::raw::c_char,
                ),
                pub getKey: unsafe extern "C" fn(
                    this: *const IRtmChannelAttribute,
                ) -> *const ::std::os::raw::c_char,
                pub setValue: unsafe extern "C" fn(
                    this: *mut IRtmChannelAttribute,
                    value: *const ::std::os::raw::c_char,
                ),
                pub getValue: unsafe extern "C" fn(
                    this: *const IRtmChannelAttribute,
                )
                    -> *const ::std::os::raw::c_char,
                pub getLastUpdateUserId: unsafe extern "C" fn(
                    this: *const IRtmChannelAttribute,
                )
                    -> *const ::std::os::raw::c_char,
                pub getLastUpdateTs: unsafe extern "C" fn(
                    this: *const IRtmChannelAttribute,
                )
                    -> ::std::os::raw::c_longlong,
                pub release: unsafe extern "C" fn(this: *mut IRtmChannelAttribute),
            }
            #[doc = "@brief The class for setting or getting attributes of a channel."]
            #[repr(C)]
            #[derive(Debug)]
            pub struct IRtmChannelAttribute {
                pub vtable_: *const IRtmChannelAttribute__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_IRtmChannelAttribute() {
                assert_eq!(
                    ::core::mem::size_of::<IRtmChannelAttribute>(),
                    8usize,
                    concat!("Size of: ", stringify!(IRtmChannelAttribute))
                );
                assert_eq!(
                    ::core::mem::align_of::<IRtmChannelAttribute>(),
                    8usize,
                    concat!("Alignment of ", stringify!(IRtmChannelAttribute))
                );
            }
            #[doc = "@brief Data structure holding channel attribute-specific options."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ChannelAttributeOptions {
                #[doc = "Indicates whether or not to notify all channel members of a channel attribute change."]
                #[doc = ""]
                #[doc = "@note This flag is valid only within the current method call."]
                #[doc = ""]
                #[doc = "- true: Notify all channel members of a channel attribute change."]
                #[doc = "- false: (Default) Do not notify all channel members of a channel attribute change."]
                pub enableNotificationToChannelMembers: bool,
            }
            #[test]
            fn bindgen_test_layout_ChannelAttributeOptions() {
                assert_eq!(
                    ::core::mem::size_of::<ChannelAttributeOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(ChannelAttributeOptions))
                );
                assert_eq!(
                    ::core::mem::align_of::<ChannelAttributeOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ChannelAttributeOptions))
                );
                fn test_field_enableNotificationToChannelMembers() {
                    assert_eq!(
                        unsafe {
                            let uninit =
                                ::core::mem::MaybeUninit::<ChannelAttributeOptions>::uninit();
                            let ptr = uninit.as_ptr();
                            ::core::ptr::addr_of!((*ptr).enableNotificationToChannelMembers)
                                as usize
                                - ptr as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ChannelAttributeOptions),
                            "::",
                            stringify!(enableNotificationToChannelMembers)
                        )
                    );
                }
                test_field_enableNotificationToChannelMembers();
            }
            #[repr(C)]
            pub struct IMessage__bindgen_vtable {
                pub getMessageId:
                    unsafe extern "C" fn(this: *const IMessage) -> ::std::os::raw::c_longlong,
                pub getMessageType:
                    unsafe extern "C" fn(this: *const IMessage) -> MESSAGE_TYPE::Type,
                pub setText:
                    unsafe extern "C" fn(this: *mut IMessage, str_: *const ::std::os::raw::c_char),
                pub getText:
                    unsafe extern "C" fn(this: *const IMessage) -> *const ::std::os::raw::c_char,
                pub getRawMessageData:
                    unsafe extern "C" fn(this: *const IMessage) -> *const ::std::os::raw::c_char,
                pub getRawMessageLength:
                    unsafe extern "C" fn(this: *const IMessage) -> ::std::os::raw::c_int,
                pub getServerReceivedTs:
                    unsafe extern "C" fn(this: *const IMessage) -> ::std::os::raw::c_longlong,
                pub isOfflineMessage: unsafe extern "C" fn(this: *const IMessage) -> bool,
                pub release: unsafe extern "C" fn(this: *mut IMessage),
            }
            #[doc = "@brief The class for setting and retrieving attributes of a channel or peer-to-peer message."]
            #[repr(C)]
            #[derive(Debug)]
            pub struct IMessage {
                pub vtable_: *const IMessage__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_IMessage() {
                assert_eq!(
                    ::core::mem::size_of::<IMessage>(),
                    8usize,
                    concat!("Size of: ", stringify!(IMessage))
                );
                assert_eq!(
                    ::core::mem::align_of::<IMessage>(),
                    8usize,
                    concat!("Alignment of ", stringify!(IMessage))
                );
            }
            #[repr(C)]
            pub struct IChannelMember__bindgen_vtable {
                pub getUserId: unsafe extern "C" fn(
                    this: *const IChannelMember,
                )
                    -> *const ::std::os::raw::c_char,
                pub getChannelId: unsafe extern "C" fn(
                    this: *const IChannelMember,
                )
                    -> *const ::std::os::raw::c_char,
                pub release: unsafe extern "C" fn(this: *mut IChannelMember),
            }
            #[doc = "@brief The class for retrieving the attributes of a channel member."]
            #[repr(C)]
            #[derive(Debug)]
            pub struct IChannelMember {
                pub vtable_: *const IChannelMember__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_IChannelMember() {
                assert_eq!(
                    ::core::mem::size_of::<IChannelMember>(),
                    8usize,
                    concat!("Size of: ", stringify!(IChannelMember))
                );
                assert_eq!(
                    ::core::mem::align_of::<IChannelMember>(),
                    8usize,
                    concat!("Alignment of ", stringify!(IChannelMember))
                );
            }
            #[doc = "@brief The data structure holding an RTM user and the user's online status."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct PeerOnlineStatus {
                #[doc = "The user ID of the peer."]
                pub peerId: *const ::std::os::raw::c_char,
                #[doc = "@deprecated Deprecated as of v1.2.0. Use \\ref agora::rtm::PeerOnlineStatus::onlineState \"onlineState\" instead."]
                #[doc = ""]
                #[doc = "The online status of the peer."]
                #[doc = ""]
                #[doc = "- true: The user is online (the user has logged in the Agora RTM system)."]
                #[doc = "- false: The user is offline (the user has logged out of the Agora RTM system, has not logged in, or has failed to logged in)."]
                pub isOnline: bool,
                #[doc = "The online state of the peer. See #PEER_ONLINE_STATE."]
                #[doc = ""]
                #[doc = "@note"]
                #[doc = "- The server will never return the `unreachable` state, if you <i>query</i> the online status of specified peers (\\ref agora::rtm::IRtmService::queryPeersOnlineStatus \"queryPeersOnlineStatus\"). See also: \\ref agora::rtm::IRtmServiceEventHandler::onQueryPeersOnlineStatusResult \"onQueryPeersOnlineStatusResult\"."]
                #[doc = "- The server may return the `unreachable` state, if you <i>subscribe to</i> the online status of specified peers (\\ref agora::rtm::IRtmService::subscribePeersOnlineStatus \"subscribePeersOnlineStatus\"). See also: \\ref agora::rtm::IRtmServiceEventHandler::onPeersOnlineStatusChanged \"onPeersOnlineStatusChanged\"."]
                pub onlineState: PEER_ONLINE_STATE::Type,
            }
            #[test]
            fn bindgen_test_layout_PeerOnlineStatus() {
                assert_eq!(
                    ::core::mem::size_of::<PeerOnlineStatus>(),
                    16usize,
                    concat!("Size of: ", stringify!(PeerOnlineStatus))
                );
                assert_eq!(
                    ::core::mem::align_of::<PeerOnlineStatus>(),
                    8usize,
                    concat!("Alignment of ", stringify!(PeerOnlineStatus))
                );
                fn test_field_peerId() {
                    assert_eq!(
                        unsafe {
                            let uninit = ::core::mem::MaybeUninit::<PeerOnlineStatus>::uninit();
                            let ptr = uninit.as_ptr();
                            ::core::ptr::addr_of!((*ptr).peerId) as usize - ptr as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(PeerOnlineStatus),
                            "::",
                            stringify!(peerId)
                        )
                    );
                }
                test_field_peerId();
                fn test_field_isOnline() {
                    assert_eq!(
                        unsafe {
                            let uninit = ::core::mem::MaybeUninit::<PeerOnlineStatus>::uninit();
                            let ptr = uninit.as_ptr();
                            ::core::ptr::addr_of!((*ptr).isOnline) as usize - ptr as usize
                        },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(PeerOnlineStatus),
                            "::",
                            stringify!(isOnline)
                        )
                    );
                }
                test_field_isOnline();
                fn test_field_onlineState() {
                    assert_eq!(
                        unsafe {
                            let uninit = ::core::mem::MaybeUninit::<PeerOnlineStatus>::uninit();
                            let ptr = uninit.as_ptr();
                            ::core::ptr::addr_of!((*ptr).onlineState) as usize - ptr as usize
                        },
                        12usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(PeerOnlineStatus),
                            "::",
                            stringify!(onlineState)
                        )
                    );
                }
                test_field_onlineState();
            }
            #[doc = "@brief The data structure holding a channel ID and the current channel member count."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ChannelMemberCount {
                #[doc = "The ID of the channel."]
                pub channelId: *const ::std::os::raw::c_char,
                #[doc = "The current member count of the channel."]
                #[doc = ""]
                #[doc = "@note @p count is 0, if a channel with the specified @p channelId is not found."]
                pub count: ::std::os::raw::c_int,
            }
            #[test]
            fn bindgen_test_layout_ChannelMemberCount() {
                assert_eq!(
                    ::core::mem::size_of::<ChannelMemberCount>(),
                    16usize,
                    concat!("Size of: ", stringify!(ChannelMemberCount))
                );
                assert_eq!(
                    ::core::mem::align_of::<ChannelMemberCount>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ChannelMemberCount))
                );
                fn test_field_channelId() {
                    assert_eq!(
                        unsafe {
                            let uninit = ::core::mem::MaybeUninit::<ChannelMemberCount>::uninit();
                            let ptr = uninit.as_ptr();
                            ::core::ptr::addr_of!((*ptr).channelId) as usize - ptr as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ChannelMemberCount),
                            "::",
                            stringify!(channelId)
                        )
                    );
                }
                test_field_channelId();
                fn test_field_count() {
                    assert_eq!(
                        unsafe {
                            let uninit = ::core::mem::MaybeUninit::<ChannelMemberCount>::uninit();
                            let ptr = uninit.as_ptr();
                            ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize
                        },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ChannelMemberCount),
                            "::",
                            stringify!(count)
                        )
                    );
                }
                test_field_count();
            }
            #[repr(C)]
            pub struct IChannelEventHandler__bindgen_vtable {}
            #[doc = "@brief Callbacks for the Agora RTM channel methods."]
            #[repr(C)]
            #[derive(Debug)]
            pub struct IChannelEventHandler {
                pub vtable_: *const IChannelEventHandler__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_IChannelEventHandler() {
                assert_eq!(
                    ::core::mem::size_of::<IChannelEventHandler>(),
                    8usize,
                    concat!("Size of: ", stringify!(IChannelEventHandler))
                );
                assert_eq!(
                    ::core::mem::align_of::<IChannelEventHandler>(),
                    8usize,
                    concat!("Alignment of ", stringify!(IChannelEventHandler))
                );
            }
            #[repr(C)]
            pub struct IChannel__bindgen_vtable {
                pub join: unsafe extern "C" fn(this: *mut IChannel) -> ::std::os::raw::c_int,
                pub leave: unsafe extern "C" fn(this: *mut IChannel) -> ::std::os::raw::c_int,
                pub sendMessage: unsafe extern "C" fn(
                    this: *mut IChannel,
                    message: *const IMessage,
                ) -> ::std::os::raw::c_int,
                pub sendMessage1: unsafe extern "C" fn(
                    this: *mut IChannel,
                    message: *const IMessage,
                    options: *const SendMessageOptions,
                ) -> ::std::os::raw::c_int,
                pub getId:
                    unsafe extern "C" fn(this: *const IChannel) -> *const ::std::os::raw::c_char,
                pub getMembers: unsafe extern "C" fn(this: *mut IChannel) -> ::std::os::raw::c_int,
                pub release: unsafe extern "C" fn(this: *mut IChannel),
            }
            #[doc = "@brief Agora RTM channel methods."]
            #[repr(C)]
            #[derive(Debug)]
            pub struct IChannel {
                pub vtable_: *const IChannel__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_IChannel() {
                assert_eq!(
                    ::core::mem::size_of::<IChannel>(),
                    8usize,
                    concat!("Size of: ", stringify!(IChannel))
                );
                assert_eq!(
                    ::core::mem::align_of::<IChannel>(),
                    8usize,
                    concat!("Alignment of ", stringify!(IChannel))
                );
            }
            #[repr(C)]
            pub struct IRtmServiceEventHandler__bindgen_vtable {}
            #[repr(C)]
            #[derive(Debug)]
            pub struct IRtmServiceEventHandler {
                pub vtable_: *const IRtmServiceEventHandler__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_IRtmServiceEventHandler() {
                assert_eq!(
                    ::core::mem::size_of::<IRtmServiceEventHandler>(),
                    8usize,
                    concat!("Size of: ", stringify!(IRtmServiceEventHandler))
                );
                assert_eq!(
                    ::core::mem::align_of::<IRtmServiceEventHandler>(),
                    8usize,
                    concat!("Alignment of ", stringify!(IRtmServiceEventHandler))
                );
            }
            pub mod LOG_FILTER_TYPE {
                #[doc = "@brief Output log filter level."]
                pub type Type = u32;
                #[doc = "0: Do not output any log information."]
                pub const LOG_FILTER_OFF: Type = 0;
                #[doc = "0x000f: Output CRITICAL, ERROR, WARNING, and INFO level log information."]
                pub const LOG_FILTER_INFO: Type = 15;
                #[doc = "0x000e: Output CRITICAL, ERROR, and WARNING level log information."]
                pub const LOG_FILTER_WARN: Type = 14;
                #[doc = "0x000c: Output CRITICAL and ERROR level log information."]
                pub const LOG_FILTER_ERROR: Type = 12;
                #[doc = "0x0008: Output CRITICAL level log information."]
                pub const LOG_FILTER_CRITICAL: Type = 8;
                #[doc = "Reserved for future use."]
                pub const LOG_FILTER_MASK: Type = 2063;
            }
            #[repr(C)]
            pub struct IRtmService__bindgen_vtable {
                pub initialize: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    appId: *const ::std::os::raw::c_char,
                    eventHandler: *mut IRtmServiceEventHandler,
                ) -> ::std::os::raw::c_int,
                pub addEventHandler: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    eventHandler: *mut IRtmServiceEventHandler,
                ),
                pub removeEventHandler: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    eventHandler: *mut IRtmServiceEventHandler,
                ),
                pub release: unsafe extern "C" fn(this: *mut IRtmService, sync: bool),
                pub login: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    token: *const ::std::os::raw::c_char,
                    userId: *const ::std::os::raw::c_char,
                ) -> ::std::os::raw::c_int,
                pub logout: unsafe extern "C" fn(this: *mut IRtmService) -> ::std::os::raw::c_int,
                pub renewToken: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    token: *const ::std::os::raw::c_char,
                ) -> ::std::os::raw::c_int,
                pub sendMessageToPeer: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    peerId: *const ::std::os::raw::c_char,
                    message: *const IMessage,
                )
                    -> ::std::os::raw::c_int,
                pub sendMessageToPeer1: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    peerId: *const ::std::os::raw::c_char,
                    message: *const IMessage,
                    options: *const SendMessageOptions,
                )
                    -> ::std::os::raw::c_int,
                pub createChannel: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    channelId: *const ::std::os::raw::c_char,
                    eventHandler: *mut IChannelEventHandler,
                ) -> *mut IChannel,
                pub getRtmCallManager: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    eventHandler: *mut IRtmCallEventHandler,
                )
                    -> *mut IRtmCallManager,
                pub createMessage: unsafe extern "C" fn(this: *mut IRtmService) -> *mut IMessage,
                pub createMessage1: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    message: *const ::std::os::raw::c_char,
                ) -> *mut IMessage,
                pub createMessage2: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    rawData: *const u8,
                    length: ::std::os::raw::c_int,
                ) -> *mut IMessage,
                pub createMessage3: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    rawData: *const u8,
                    length: ::std::os::raw::c_int,
                    description: *const ::std::os::raw::c_char,
                ) -> *mut IMessage,
                pub createChannelAttribute:
                    unsafe extern "C" fn(this: *mut IRtmService) -> *mut IRtmChannelAttribute,
                pub setParameters: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    parameters: *const ::std::os::raw::c_char,
                ) -> ::std::os::raw::c_int,
                pub queryPeersOnlineStatus: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    peerIds: *mut *const ::std::os::raw::c_char,
                    peerCount: ::std::os::raw::c_int,
                    requestId: *mut ::std::os::raw::c_longlong,
                )
                    -> ::std::os::raw::c_int,
                pub subscribePeersOnlineStatus: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    peerIds: *mut *const ::std::os::raw::c_char,
                    peerCount: ::std::os::raw::c_int,
                    requestId: *mut ::std::os::raw::c_longlong,
                )
                    -> ::std::os::raw::c_int,
                pub unsubscribePeersOnlineStatus: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    peerIds: *mut *const ::std::os::raw::c_char,
                    peerCount: ::std::os::raw::c_int,
                    requestId: *mut ::std::os::raw::c_longlong,
                )
                    -> ::std::os::raw::c_int,
                pub queryPeersBySubscriptionOption: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    option: PEER_SUBSCRIPTION_OPTION::Type,
                    requestId: *mut ::std::os::raw::c_longlong,
                )
                    -> ::std::os::raw::c_int,
                pub setLocalUserAttributes: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    attributes: *const RtmAttribute,
                    numberOfAttributes: ::std::os::raw::c_int,
                    requestId: *mut ::std::os::raw::c_longlong,
                )
                    -> ::std::os::raw::c_int,
                pub addOrUpdateLocalUserAttributes: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    attributes: *const RtmAttribute,
                    numberOfAttributes: ::std::os::raw::c_int,
                    requestId: *mut ::std::os::raw::c_longlong,
                )
                    -> ::std::os::raw::c_int,
                pub deleteLocalUserAttributesByKeys: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    attributeKeys: *mut *const ::std::os::raw::c_char,
                    numberOfKeys: ::std::os::raw::c_int,
                    requestId: *mut ::std::os::raw::c_longlong,
                )
                    -> ::std::os::raw::c_int,
                pub clearLocalUserAttributes: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    requestId: *mut ::std::os::raw::c_longlong,
                )
                    -> ::std::os::raw::c_int,
                pub getUserAttributes: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    userId: *const ::std::os::raw::c_char,
                    requestId: *mut ::std::os::raw::c_longlong,
                )
                    -> ::std::os::raw::c_int,
                pub getUserAttributesByKeys: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    userId: *const ::std::os::raw::c_char,
                    attributeKeys: *mut *const ::std::os::raw::c_char,
                    numberOfKeys: ::std::os::raw::c_int,
                    requestId: *mut ::std::os::raw::c_longlong,
                )
                    -> ::std::os::raw::c_int,
                pub setChannelAttributes: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    channelId: *const ::std::os::raw::c_char,
                    attributes: *mut *const IRtmChannelAttribute,
                    numberOfAttributes: ::std::os::raw::c_int,
                    options: *const ChannelAttributeOptions,
                    requestId: *mut ::std::os::raw::c_longlong,
                )
                    -> ::std::os::raw::c_int,
                pub addOrUpdateChannelAttributes: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    channelId: *const ::std::os::raw::c_char,
                    attributes: *mut *const IRtmChannelAttribute,
                    numberOfAttributes: ::std::os::raw::c_int,
                    options: *const ChannelAttributeOptions,
                    requestId: *mut ::std::os::raw::c_longlong,
                )
                    -> ::std::os::raw::c_int,
                pub deleteChannelAttributesByKeys: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    channelId: *const ::std::os::raw::c_char,
                    attributeKeys: *mut *const ::std::os::raw::c_char,
                    numberOfKeys: ::std::os::raw::c_int,
                    options: *const ChannelAttributeOptions,
                    requestId: *mut ::std::os::raw::c_longlong,
                )
                    -> ::std::os::raw::c_int,
                pub clearChannelAttributes: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    channelId: *const ::std::os::raw::c_char,
                    options: *const ChannelAttributeOptions,
                    requestId: *mut ::std::os::raw::c_longlong,
                )
                    -> ::std::os::raw::c_int,
                pub getChannelAttributes: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    channelId: *const ::std::os::raw::c_char,
                    requestId: *mut ::std::os::raw::c_longlong,
                )
                    -> ::std::os::raw::c_int,
                pub getChannelAttributesByKeys: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    channelId: *const ::std::os::raw::c_char,
                    attributeKeys: *mut *const ::std::os::raw::c_char,
                    numberOfKeys: ::std::os::raw::c_int,
                    requestId: *mut ::std::os::raw::c_longlong,
                )
                    -> ::std::os::raw::c_int,
                pub getChannelMemberCount: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    channelIds: *mut *const ::std::os::raw::c_char,
                    channelCount: ::std::os::raw::c_int,
                    requestId: *mut ::std::os::raw::c_longlong,
                )
                    -> ::std::os::raw::c_int,
                pub setLogFile: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    logfile: *const ::std::os::raw::c_char,
                ) -> ::std::os::raw::c_int,
                pub setLogFilter: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    filter: LOG_FILTER_TYPE::Type,
                ) -> ::std::os::raw::c_int,
                pub setLogFileSize: unsafe extern "C" fn(
                    this: *mut IRtmService,
                    fileSizeInKBytes: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IRtmService {
                pub vtable_: *const IRtmService__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_IRtmService() {
                assert_eq!(
                    ::core::mem::size_of::<IRtmService>(),
                    8usize,
                    concat!("Size of: ", stringify!(IRtmService))
                );
                assert_eq!(
                    ::core::mem::align_of::<IRtmService>(),
                    8usize,
                    concat!("Alignment of ", stringify!(IRtmService))
                );
            }
            extern "C" {
                #[doc = "Creates an \\ref agora::rtm::IRtmService \"IRtmService\" instance."]
                #[doc = ""]
                #[doc = "@note When you no longer need an \\ref agora::rtm::IRtmService \"IRtmService\" instance, ensure that you call the \\ref agora::rtm::IRtmService::release \"release\" method to release all resources that it uses."]
                #[doc = ""]
                #[doc = "@return An \\ref agora::rtm::IRtmService \"IRtmService\" instance."]
                pub fn createRtmService() -> *mut IRtmService;
            }
            extern "C" {
                #[doc = "Gets the version of the Agora RTM SDK."]
                #[doc = ""]
                #[doc = "@return The version of the Agora RTM SDK."]
                pub fn getRtmSdkVersion() -> *const ::std::os::raw::c_char;
            }
            pub mod RTM_AREA_CODE {
                #[doc = "Region for the Agora RTM service. After setting a region, the RTM SDK can only connect to the Agora RTM service in the specified region."]
                pub type Type = u32;
                #[doc = " Mainland China."]
                pub const AREA_CODE_CN: Type = 1;
                #[doc = " North America."]
                pub const AREA_CODE_NA: Type = 2;
                #[doc = " Europe."]
                pub const AREA_CODE_EU: Type = 4;
                #[doc = " Asia excluding Mainland China."]
                pub const AREA_CODE_AS: Type = 8;
                #[doc = " Japan."]
                pub const AREA_CODE_JP: Type = 16;
                #[doc = " India."]
                pub const AREA_CODE_IN: Type = 32;
                #[doc = " (Default) Global."]
                pub const AREA_CODE_GLOB: Type = 4294967295;
            }
            pub mod RTM_CLOUD_PROXY_TYPE {
                pub type Type = u32;
                #[doc = " No cloud proxy."]
                pub const RTM_NONE_PROXY: Type = 0;
                #[doc = " TLS cloud proxy."]
                pub const RTM_TCP_PROXY: Type = 1;
            }
            #[doc = "Context of the `%IRtmService` instance."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct RtmServiceContext {
                #[doc = " Region for the Agora RTM service. The default is #AREA_CODE_GLOB."]
                pub areaCode: ::std::os::raw::c_int,
                #[doc = " Type of the cloud proxy. The default is `RTM_NONE_PROXY`. See #RTM_CLOUD_PROXY_TYPE."]
                pub proxyType: RTM_CLOUD_PROXY_TYPE::Type,
            }
            #[test]
            fn bindgen_test_layout_RtmServiceContext() {
                assert_eq!(
                    ::core::mem::size_of::<RtmServiceContext>(),
                    8usize,
                    concat!("Size of: ", stringify!(RtmServiceContext))
                );
                assert_eq!(
                    ::core::mem::align_of::<RtmServiceContext>(),
                    4usize,
                    concat!("Alignment of ", stringify!(RtmServiceContext))
                );
                fn test_field_areaCode() {
                    assert_eq!(
                        unsafe {
                            let uninit = ::core::mem::MaybeUninit::<RtmServiceContext>::uninit();
                            let ptr = uninit.as_ptr();
                            ::core::ptr::addr_of!((*ptr).areaCode) as usize - ptr as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RtmServiceContext),
                            "::",
                            stringify!(areaCode)
                        )
                    );
                }
                test_field_areaCode();
                fn test_field_proxyType() {
                    assert_eq!(
                        unsafe {
                            let uninit = ::core::mem::MaybeUninit::<RtmServiceContext>::uninit();
                            let ptr = uninit.as_ptr();
                            ::core::ptr::addr_of!((*ptr).proxyType) as usize - ptr as usize
                        },
                        4usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RtmServiceContext),
                            "::",
                            stringify!(proxyType)
                        )
                    );
                }
                test_field_proxyType();
            }
            pub mod SET_RTM_SERVICE_CONTEXT_ERR_CODE {
                #[doc = "Error codes returned by \\ref agora::rtm::setRtmServiceContext \"setRtmServiceContext\". See #RTM_AREA_CODE."]
                pub type Type = u32;
                #[doc = "0: Successfully configured the context for the Agora RTM service."]
                pub const SET_RTM_SERVICE_CONTEXT_ERR_OK: Type = 0;
                #[doc = "1: Failed to configure the context for the Agora RTM service because at least one \\ref agora::rtm::IRtmService \"IRtmService\" instance already exists. Call \\ref agora::rtm::IRtmService::release \"release\" to destroy any existing `%IRtmService` instance before configuring the context for the Agora RTM service."]
                pub const SET_RTM_SERVICE_CONTEXT_ERR_FAILURE: Type = 1;
            }
            extern "C" {
                #[doc = "Sets the context of all `IRtmService` instances. All `%IRtmservice` instances you create after calling this method match the context."]
                #[doc = ""]
                #[doc = "@note You must call this method before calling #createRtmService to create an `%IRtmservice` instance or after destroying any existing `%IRtmservice` instance. Otherwise, this method returns the #SET_RTM_SERVICE_CONTEXT_ERR_FAILURE error code."]
                #[doc = ""]
                #[doc = "@param context Context of the `%IRtmservice` instance, including geofencing and cloud proxy. See \\ref agora::rtm::RtmServiceContext \"RtmServiceContext\"."]
                #[doc = ""]
                #[doc = "@return #SET_RTM_SERVICE_CONTEXT_ERR_CODE."]
                pub fn setRtmServiceContext(
                    context: *const RtmServiceContext,
                ) -> SET_RTM_SERVICE_CONTEXT_ERR_CODE::Type;
            }
            pub mod LOCAL_INVITATION_STATE {
                #[doc = "@brief <b>RETURNED TO THE CALLER.</b> States of an outgoing call invitation."]
                pub type Type = u32;
                #[doc = "0: <b>RETURNED TO THE CALLER.</b> The initial state of a call invitation (idle)."]
                pub const LOCAL_INVITATION_STATE_IDLE: Type = 0;
                #[doc = "1: <b>RETURNED TO THE CALLER.</b> The call invitation is sent to the callee."]
                pub const LOCAL_INVITATION_STATE_SENT_TO_REMOTE: Type = 1;
                #[doc = "2: <b>RETURNED TO THE CALLER.</b> The call invitation is received by the callee."]
                pub const LOCAL_INVITATION_STATE_RECEIVED_BY_REMOTE: Type = 2;
                #[doc = "3: <b>RETURNED TO THE CALLER.</b> The call invitation is accepted by the callee."]
                pub const LOCAL_INVITATION_STATE_ACCEPTED_BY_REMOTE: Type = 3;
                #[doc = "4: <b>RETURNED TO THE CALLER.</b> The call invitation is declined by the callee."]
                pub const LOCAL_INVITATION_STATE_REFUSED_BY_REMOTE: Type = 4;
                #[doc = "5: <b>RETURNED TO THE CALLER.</b> You have canceled the call invitation."]
                pub const LOCAL_INVITATION_STATE_CANCELED: Type = 5;
                #[doc = "6: <b>RETURNED TO THE CALLER.</b> The call invitation fails."]
                pub const LOCAL_INVITATION_STATE_FAILURE: Type = 6;
            }
            pub mod REMOTE_INVITATION_STATE {
                #[doc = "@brief <b>RETURNED TO THE CALLEE.</b> States of an incoming call invitation."]
                pub type Type = u32;
                #[doc = "0: <b>RETURNED TO THE CALLEE.</b> The initial state of a call invitation (idle)."]
                pub const REMOTE_INVITATION_STATE_IDLE: Type = 0;
                #[doc = "1: <b>RETURNED TO THE CALLEE.</b> A call invitation from a remote caller is received."]
                pub const REMOTE_INVITATION_STATE_INVITATION_RECEIVED: Type = 1;
                #[doc = "2: <b>RETURNED TO THE CALLEE.</b> The message is sent to the caller that the call invitation is accepted."]
                pub const REMOTE_INVITATION_STATE_ACCEPT_SENT_TO_LOCAL: Type = 2;
                #[doc = "3: <b>RETURNED TO THE CALLEE.</b> You have declined the call invitation."]
                pub const REMOTE_INVITATION_STATE_REFUSED: Type = 3;
                #[doc = "4: <b>RETURNED TO THE CALLEE.</b> You have accepted the call invitation."]
                pub const REMOTE_INVITATION_STATE_ACCEPTED: Type = 4;
                #[doc = "5: <b>RETURNED TO THE CALLEE.</b> The call invitation is canceled by the remote caller."]
                pub const REMOTE_INVITATION_STATE_CANCELED: Type = 5;
                #[doc = "6: <b>RETURNED TO THE CALLEE.</b> The call invitation fails."]
                pub const REMOTE_INVITATION_STATE_FAILURE: Type = 6;
            }
            pub mod LOCAL_INVITATION_ERR_CODE {
                #[doc = "@brief <b>RETURNED TO THE CALLER.</b> Error codes of an outgoing call invitation."]
                pub type Type = u32;
                #[doc = "0: <b>RETURNED TO THE CALLER.</b> The outgoing invitation succeeds."]
                pub const LOCAL_INVITATION_ERR_OK: Type = 0;
                #[doc = "1: <b>RETURNED TO THE CALLER.</b> The callee is offline."]
                #[doc = ""]
                #[doc = "The SDK performs the following:"]
                #[doc = "- Keeps resending the call invitation to the callee, if the callee is offline."]
                #[doc = "- Returns this error code, if the callee is still offline 30 seconds since the call invitation is sent."]
                pub const LOCAL_INVITATION_ERR_PEER_OFFLINE: Type = 1;
                #[doc = "2: <b>RETURNED TO THE CALLER.</b> The callee is online but has not ACKed to the call invitation 30 seconds since it is sent."]
                pub const LOCAL_INVITATION_ERR_PEER_NO_RESPONSE: Type = 2;
                #[doc = "3: <b>RETURNED TO THE CALLER. SAVED FOR FUTURE USE.</b> The call invitation expires 60 seconds since it is sent, if the callee ACKs to the call invitation but neither the caller or callee takes any further action (cancel, accpet, or decline it)."]
                pub const LOCAL_INVITATION_ERR_INVITATION_EXPIRE: Type = 3;
                #[doc = "4: <b>RETURNED TO THE CALLER.</b> The caller is not logged in."]
                pub const LOCAL_INVITATION_ERR_NOT_LOGGEDIN: Type = 4;
            }
            pub mod REMOTE_INVITATION_ERR_CODE {
                #[doc = "@brief <b>RETURNED TO THE CALLEE.</b> Error codes of an incoming call invitation."]
                pub type Type = u32;
                #[doc = "0: <b>RETURNED TO THE CALLEE.</b> The incoming calll invitation succeeds."]
                pub const REMOTE_INVITATION_ERR_OK: Type = 0;
                #[doc = "1: <b>RETURNED TO THE CALLEE.</b> The call invitation received by the callee fails: the callee is not online."]
                pub const REMOTE_INVITATION_ERR_PEER_OFFLINE: Type = 1;
                #[doc = "2: <b>RETURNED TO THE CALLEE.</b> The call invitation received by callee fails: The callee does not ACK within a set time after the callee accepts the call invitation. This is usually a result of a network interruption."]
                pub const REMOTE_INVITATION_ERR_ACCEPT_FAILURE: Type = 2;
                #[doc = "3: <b>RETURNED TO THE CALLEE.</b> The call invitation expires 60 seconds since it is sent, if the callee ACKs to the call invitation but neither the caller or callee takes any further action (cancel, accpet, or decline it)."]
                pub const REMOTE_INVITATION_ERR_INVITATION_EXPIRE: Type = 3;
            }
            pub mod INVITATION_API_CALL_ERR_CODE {
                #[doc = "@brief Error codes of the call invitation methods."]
                pub type Type = u32;
                #[doc = "0: The method call succeeds."]
                pub const INVITATION_API_CALL_ERR_OK: Type = 0;
                #[doc = "1: The method call fails. The argument is invalid, for example, the value of the @p content parameter exceeds 8K bytes."]
                pub const INVITATION_API_CALL_ERR_INVALID_ARGUMENT: Type = 1;
                #[doc = "2: The method call fails. The call invitation has not started."]
                pub const INVITATION_API_CALL_ERR_NOT_STARTED: Type = 2;
                #[doc = "3: The method call fails. The call invitation has ended."]
                pub const INVITATION_API_CALL_ERR_ALREADY_END: Type = 3;
                #[doc = "4: The method call fails. The call invitation is already accepted."]
                pub const INVITATION_API_CALL_ERR_ALREADY_ACCEPT: Type = 4;
                #[doc = "5: The method call fails. The call invitation is already sent."]
                pub const INVITATION_API_CALL_ERR_ALREADY_SENT: Type = 5;
            }
            #[repr(C)]
            pub struct ILocalCallInvitation__bindgen_vtable {
                pub getCalleeId: unsafe extern "C" fn(
                    this: *const ILocalCallInvitation,
                )
                    -> *const ::std::os::raw::c_char,
                pub setContent: unsafe extern "C" fn(
                    this: *mut ILocalCallInvitation,
                    content: *const ::std::os::raw::c_char,
                ),
                pub getContent: unsafe extern "C" fn(
                    this: *const ILocalCallInvitation,
                )
                    -> *const ::std::os::raw::c_char,
                pub setChannelId: unsafe extern "C" fn(
                    this: *mut ILocalCallInvitation,
                    channelId: *const ::std::os::raw::c_char,
                ),
                pub getChannelId: unsafe extern "C" fn(
                    this: *const ILocalCallInvitation,
                )
                    -> *const ::std::os::raw::c_char,
                pub getResponse: unsafe extern "C" fn(
                    this: *const ILocalCallInvitation,
                )
                    -> *const ::std::os::raw::c_char,
                pub getState: unsafe extern "C" fn(
                    this: *const ILocalCallInvitation,
                ) -> LOCAL_INVITATION_STATE::Type,
                pub release: unsafe extern "C" fn(this: *mut ILocalCallInvitation),
            }
            #[doc = "The class allowing the caller to retrieve the attributes of an outgoing call invitation."]
            #[repr(C)]
            #[derive(Debug)]
            pub struct ILocalCallInvitation {
                pub vtable_: *const ILocalCallInvitation__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_ILocalCallInvitation() {
                assert_eq!(
                    ::core::mem::size_of::<ILocalCallInvitation>(),
                    8usize,
                    concat!("Size of: ", stringify!(ILocalCallInvitation))
                );
                assert_eq!(
                    ::core::mem::align_of::<ILocalCallInvitation>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ILocalCallInvitation))
                );
            }
            #[repr(C)]
            pub struct IRemoteCallInvitation__bindgen_vtable {
                pub getCallerId: unsafe extern "C" fn(
                    this: *const IRemoteCallInvitation,
                )
                    -> *const ::std::os::raw::c_char,
                pub getContent: unsafe extern "C" fn(
                    this: *const IRemoteCallInvitation,
                )
                    -> *const ::std::os::raw::c_char,
                pub setResponse: unsafe extern "C" fn(
                    this: *mut IRemoteCallInvitation,
                    response: *const ::std::os::raw::c_char,
                ),
                pub getResponse: unsafe extern "C" fn(
                    this: *const IRemoteCallInvitation,
                )
                    -> *const ::std::os::raw::c_char,
                pub getChannelId: unsafe extern "C" fn(
                    this: *const IRemoteCallInvitation,
                )
                    -> *const ::std::os::raw::c_char,
                pub getState: unsafe extern "C" fn(
                    this: *const IRemoteCallInvitation,
                )
                    -> REMOTE_INVITATION_STATE::Type,
                pub release: unsafe extern "C" fn(this: *mut IRemoteCallInvitation),
            }
            #[doc = "The class allowing the callee to retrieve the attributes of an incoming call invitation."]
            #[repr(C)]
            #[derive(Debug)]
            pub struct IRemoteCallInvitation {
                pub vtable_: *const IRemoteCallInvitation__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_IRemoteCallInvitation() {
                assert_eq!(
                    ::core::mem::size_of::<IRemoteCallInvitation>(),
                    8usize,
                    concat!("Size of: ", stringify!(IRemoteCallInvitation))
                );
                assert_eq!(
                    ::core::mem::align_of::<IRemoteCallInvitation>(),
                    8usize,
                    concat!("Alignment of ", stringify!(IRemoteCallInvitation))
                );
            }
            #[repr(C)]
            pub struct IRtmCallEventHandler__bindgen_vtable {}
            #[doc = "Callbacks for the call invitation methods."]
            #[repr(C)]
            #[derive(Debug)]
            pub struct IRtmCallEventHandler {
                pub vtable_: *const IRtmCallEventHandler__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_IRtmCallEventHandler() {
                assert_eq!(
                    ::core::mem::size_of::<IRtmCallEventHandler>(),
                    8usize,
                    concat!("Size of: ", stringify!(IRtmCallEventHandler))
                );
                assert_eq!(
                    ::core::mem::align_of::<IRtmCallEventHandler>(),
                    8usize,
                    concat!("Alignment of ", stringify!(IRtmCallEventHandler))
                );
            }
            #[repr(C)]
            pub struct IRtmCallManager__bindgen_vtable {
                pub sendLocalInvitation: unsafe extern "C" fn(
                    this: *mut IRtmCallManager,
                    invitation: *mut ILocalCallInvitation,
                )
                    -> ::std::os::raw::c_int,
                pub acceptRemoteInvitation: unsafe extern "C" fn(
                    this: *mut IRtmCallManager,
                    invitation: *mut IRemoteCallInvitation,
                )
                    -> ::std::os::raw::c_int,
                pub refuseRemoteInvitation: unsafe extern "C" fn(
                    this: *mut IRtmCallManager,
                    invitation: *mut IRemoteCallInvitation,
                )
                    -> ::std::os::raw::c_int,
                pub cancelLocalInvitation: unsafe extern "C" fn(
                    this: *mut IRtmCallManager,
                    invitation: *mut ILocalCallInvitation,
                )
                    -> ::std::os::raw::c_int,
                pub createLocalCallInvitation: unsafe extern "C" fn(
                    this: *mut IRtmCallManager,
                    calleeId: *const ::std::os::raw::c_char,
                )
                    -> *mut ILocalCallInvitation,
                pub release: unsafe extern "C" fn(this: *mut IRtmCallManager),
            }
            #[doc = "RTM call manager methods."]
            #[repr(C)]
            #[derive(Debug)]
            pub struct IRtmCallManager {
                pub vtable_: *const IRtmCallManager__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_IRtmCallManager() {
                assert_eq!(
                    ::core::mem::size_of::<IRtmCallManager>(),
                    8usize,
                    concat!("Size of: ", stringify!(IRtmCallManager))
                );
                assert_eq!(
                    ::core::mem::align_of::<IRtmCallManager>(),
                    8usize,
                    concat!("Alignment of ", stringify!(IRtmCallManager))
                );
            }
        }
    }
    pub type __builtin_va_list = *mut ::std::os::raw::c_char;
}
